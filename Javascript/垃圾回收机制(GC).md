# 垃圾回收机制(GC)

## 浏览器

### 方式

#### 引用计数

##### 在最初，浏览器使用引用计数的方式来进行垃圾回收，

浏览器为每个变量添加一个记录引用次数的属性，当引
用次数为0时，当浏览器进行垃圾回收时，会清除这些引用次数为0的变量

#### 标记清除

##### 当函数执行时，回收机制会对函数内部的变量添加一个
"进入环境"的标记。当函数执行完成之后，又会给变量
添加一个"离开环境的标记".而在垃圾回收机制运行时，
会清除这些标记为"离开环境"的变量

#### 为什么浏览器的垃圾回收机制由 引用计数 变为 标记清除 

##### 由于引用计数在某些应该清除的情况下没有清除
比如 ，对象的循环引用 、闭包。对于这些情况下，
如果想要清除，必须手动的将变量置为null。

## Node

### 内存管理

#### 新生代内存空间（存放存活时间短的变量）

##### 分为From（使用）、To（闲置）两种内存。垃圾回收机制运行时，
会检查From内存，将需要回收的变量留在From内存，
剩下的变量移动到To内存，最后将From 和To内存中
的值反转。再回收To空间的变量

##### 新生代对象的晋升到老生带内存空间的方式

###### 在垃圾回收时，多次没有被回收

###### 在垃圾回收运行时，From内存与To内存进行反转时，当To的空间使用量超过某个阈值时（25%）

#### 老生带内存空间（存放存活时间长的变量）

##### 老生带内存空间是一个连续的内存空间，

##### 垃圾回收机制

###### 标记清除

####### 对需要清除的对象进行标记，在垃圾回收时进行清除，
但是这样会导致内存的不连续

###### 标记合并

####### 同样也是对将要清除的对象进行标记，然后将需要清除
的对象移动到一边，不需要清除的对象移动到另一边，
在垃圾回收时，只需要清除一边的内存。这样不会导致
内存的不连续

## 引起内存泄漏的方式

### 定义的全局变量

#### 全局变量一直存在，无法被回收

### 闭包

#### 不正确的写法会使得闭包无法被回收

### DOM节点绑定的事件

### 使用定时器

## GC的缺陷

### 当执行垃圾回收时，会停止所有的响应。为了安全考虑。
对于一般应用来说还好，但对于那些对连贯性要求比较
高的应用来说，会导致短时间内没有响应

## GC的优化策略

### 分代回收

#### 区分“临时对象”和“持久对象”，在垃圾回收时，
多回收“临时变量”，少回收“持久变量”。可以缩小
垃圾回收所需要的遍历的对象大小。缩短垃圾回收的处
理时间

### 增量GC

#### 多次回收，一次回收一部分，但是这样会造成，
应用中断次数增多，上下文频繁切换
