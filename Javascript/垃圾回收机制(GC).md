# 垃圾回收机制(GC)

## 浏览器

### 引用计数

> 最早的垃圾回收机制

  1. 当生命一个变量并且将一个引用类型赋值给该变量时，这个值的引用次数为1
  2. 如果另一个变量再次引用该变量时，引用次数加1
  3. 当该变量不被引用时，引用次数变为0
  4. 当垃圾回收机制工作时，会将引用次数为0的变量进行回收

> 优点

  1. 引用计数机制在变量引用为0时，变量会被立即回收

> 缺点

  1. 无法回收循环引用的变量内存

### 标记清除

  1. 垃圾收集器在运行时给内存中的所有变量加上一个标记0，
  2. 然后充各个根对象开始遍历，把不是垃圾的遍历改为1
  3. 清理所有标记为0的变量，销毁并回收他们所占用的内存
  4. 最后，把内存中所有对象标记修改为0，等待下一次垃圾回收

> 优点

  1. 实现比较简单

> 缺点

  1. 标记清除最大的缺点就是，垃圾清除之后，会导致内存空间不连续，出现内存碎片
  2. 分配速度慢，因为垃圾回收导致内存的不连续，所以在再次分配内存时，会导致大对象的内存分配效率变慢

![标记清除前后内存情况](/images/JavaScript/标记清除前后内存情况.png)

> 标记清除缺点补充

  1. 当垃圾被回收后，出现不连续内存时，使用 `标记整理算法`,可以有效的解决内存不连续的问题
  2. 具体实现逻辑：在标记结束后，`标记整理算法`将活着的对象向内存的一端移动，最后清理掉边界内存

![标记清除内存不连续问题解决-标记整理](/images/JavaScript/标记清除内存不连续问题解决-标记整理.png)

## V8引擎对 GC 的优化

  1. 分代垃圾回收

    * v8 将内存分为`新生代`、`老生代`两个区域，采用不同的策略管理垃圾回收
    * `新生代`的对象为`存活时间较短`的对象，简单来说就是新产生的对象。内存大小为`1M-8M`。
    * `老生代`的对象为`存活时间较长或常驻内存`的对象。老生代容量通常比较大

![v8垃圾回收优化-新生代、老生代](/images/JavaScript/v8垃圾回收优化-新生代、老生代.png)

### 新生代内存垃圾回收

* 新生代对象是通过一个名为`Scavenge 算法`进行垃圾回收，算法主要采用一种复制式的方式`Cheney 算法`
* `Cheney 算法`将内存一分为二，一个是处于使用状态的空间`使用区`，一种是出于闲置状态的空间`空闲区`
* 新加入的对象都会存放到`使用区`，当`使用区`快被写满时，就需要执行一次垃圾回收
* 开始垃圾回收时，新生代垃圾回收器会对`使用区`中的活动对象做标记，标记完成后，将`使用区`的活动对象复制进`空闲区`并进行排序，随后进入垃圾回收阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把`原来的使用区`变为`空闲区`，把`原来的空闲区`变为`使用区`。
* 当一个对象经过多次复制后仍然存活，它将被认为是生命周期较长的对象，随后被移入`老生代`。`采用老生代的垃圾回收策略进行管理`
* 还有另一种情况，如果复制一个对象到`空闲区`时，空闲区占用超过了 25%，那么这个对象将直接`晋升到`老生代。设置为 25% 的原因是，当完成 `Scavenge`回收后，空闲区将与使用区进行翻转，继续进行对象内存的分配，若占比过大，将会影响后续的内存分配。

![垃圾回收优化-新生代回收](/images/JavaScript/垃圾回收优化-新生代回收.png)

### 老生代垃圾回收

> 相比于`新生代垃圾回收`机制，`老生代垃圾回收`采用了`标记清除算法`。

* 标记阶段：从一组根元素开始，递归遍历这组根元素，如果能访问到的元素称为`活动对象`，访问不到的元素称为`非活动对象`
* 清理阶段：老生代垃圾回收会直接将`非活动对象`进行清理
* 产生了不连续内存情况，采用了`标记整理`来进行内存空间优化

### 为什么需要分代式

> 分代式的机制，将一些 新、小、存活时间短的对象作为`新生代`，采用一块内存频率较高的快速清理。

> 而一些 大、老、存活时间长的对象作为`老生代`，使其很少接受检查。新老生代的垃圾回收机制及频率是不同的。可以说此机制很大程度上提高了垃圾回收的效率

## 并行回收

> `全停顿`：javascript 是一门单线程语言，它运行在主线程上。在执行垃圾回收时，会阻塞脚本的执行，需要等待垃圾回收执行完毕后才会继续执行 JavaScript 脚本。如果垃圾回收执行过长，会导致页面卡顿。

> `并行策略`：`新生代`垃圾回收策略就是采用的`并行策略`，同时开启多个线程负责`新生代`的垃圾回收。由于这个过程中数据地址会发生变化，所以还需要同步更新这些对象的指针。

## 增量标记与懒性清理

> `并行回收`虽然提高了垃圾回收的效率，对于新生代垃圾回收能够有很好的优化，但是它还是一个`全停顿`的垃圾回收方式。

> 对于老生代来说，它内部存放的都是一些比较大的对象，对于这些较大对象，即使我们使用`并行策略`依然会消耗大量时间

> 所以为了减少`全停顿`时间，v8对老生代的`标记清除`进行了优化，从`全停顿`切换到了`增量标记`

## 什么是增量

> 增量就是将一次 `GC` 分为多不执行。一次只执行一小部分。

![浏览器垃圾回收-全停顿-增量](/images/JavaScript/浏览器垃圾回收-全停顿-增量.png)

## 三色标记法（暂停与恢复）

> 老生代使用`标记清除`，黑、白标记`活动对象`、`非活动对象`

> 当添加了`增量标记`之后，黑、白标记不够用了，后来添加了 灰。

> 三色标记法即使使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：黑、白、灰。

  * 白色表示未被标记的对象
  * 灰色表示自身被标记、成员变量（该对象的引用对象）未被标记
  * 黑色表示自身和成员变量都被标记

![浏览器垃圾回收-三色标记法](/images/JavaScript/浏览器垃圾回收-三色标记法.png)

> 垃圾回收执行时，所有对象都是`白色`的（没有标记），从根元素开始遍历并`标记为灰色`并推入标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象时，将其由灰色变为黑色，并将自身的下一个引用对象标记为`灰色`。就这样一直遍历下去。直到没有可标记`灰色`的对象,也就是`不可达对象`。垃圾回收将标记为`白色`的对象进行清理

> 采用 三色标记法 后，在我们恢复执行时，直接通过当前内存中有没有灰色节点来判断整个标记是否完成。如果没有灰色节点，直接进入清理阶段，如果还有灰色节点，垃圾回收恢复执行时，直接从灰色节点开始执行

> 三色标记法的mark 操作，可以渐进执行而不需要每次都扫描整个内存空间，可以很好的配合`增量回收`进行暂时恢复等一些操作，从而减少`全停顿`时间

## 写屏障（增量中修改引用）

> 当一次完整的`GC`暂停后，执行任务程序时，内存中标记好的对象引用关系被修改了

> 为了解决这个问题。v8 `增量回收`使用`写屏障`机制。即一旦黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，从而保证下一次增量`GC`标记阶段可以正确标记，这个机制被称为`强三色不变性`

## 惰性清理

> `增量标记`其实只是对`活动对象`和`非活动对象`进行标记，对于真正的清理释放内存，v8采用的是`惰性清理`。

> `增量标记`完成后，`惰性清理`就开始了。当`增量标记`执行完毕之后，如果当前可用内存还有足够的剩余，我们没必要立即执行`垃圾回收`，可以先执行 javascript 代码，非活动对象内存延迟清理。或者是分次对非活动对象的内存进行清理。

## 增量标记和惰性清理的优缺点

* 优点：减少了`全停顿`时间，使用户与浏览器交互过程更加流程
* 缺点：每个增量标记之间执行 JavaScript 代码，堆中的对象引用可能发生变化，需要`写屏障`来进行维护。`增量标记`并没有减少主线程的总暂停时间，甚至会略微增加。

## 并发回收

> 在主线程执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收时，主线程可以自由执行而不会被挂起

> 由于主线程在执行 JavaScript 过程中，辅助线程同时在进行垃圾回收，会导致`堆中对象的引用关系随时都有可能发生变化`。这时就需要额外的实现一下`读写锁机制`来进行控制

## V8中 GC 优化

> `增量标记`、`惰性清理`、`并行回收`三种方式各有优缺点。所以在`老生代`中，这三种方式是融合使用的

## 参考

* [「硬核JS」你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214)
* [前端面试：谈谈 JS 垃圾回收机制](https://segmentfault.com/a/1190000018605776)
