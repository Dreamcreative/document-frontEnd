# 垃圾回收机制(GC)

## 浏览器

### 引用计数

> 最早的垃圾回收机制

  1. 当生命一个变量并且将一个引用类型赋值给该变量时，这个值的引用次数为1
  2. 如果另一个变量再次引用该变量时，引用次数加1
  3. 当该变量不被引用时，引用次数变为0
  4. 当垃圾回收机制工作时，会将引用次数为0的变量进行回收

> 优点

  1. 引用计数机制在变量引用为0时，变量会被立即回收

> 缺点

  1. 无法回收循环引用的变量内存

### 标记清除

  1. 垃圾收集器在运行时给内存中的所有变量加上一个标记0，
  2. 然后充各个根对象开始遍历，把不是垃圾的遍历改为1
  3. 清理所有标记为0的变量，销毁并回收他们所占用的内存
  4. 最后，把内存中所有对象标记修改为0，等待下一次垃圾回收

> 优点

  1. 实现比较简单

> 缺点

  1. 标记清除最大的缺点就是，垃圾清除之后，会导致内存空间不连续，出现内存碎片
  2. 分配速度慢，因为垃圾回收导致内存的不连续，所以在再次分配内存时，会导致大对象的内存分配效率变慢

![标记清除前后内存情况](/images/JavaScript/标记清除前后内存情况.png)

> 标记清除缺点补充

  1. 当垃圾被回收后，出现不连续内存时，使用 `标记整理算法`,可以有效的解决内存不连续的问题
  2. 具体实现逻辑：在标记结束后，`标记整理算法`将活着的对象向内存的一端移动，最后清理掉边界内存

![标记清除内存不连续问题解决-标记整理](/images/JavaScript/标记清除内存不连续问题解决-标记整理.png)

## V8引擎对 GC 的优化

  1. 分代垃圾回收

    * v8 将内存分为`新生代`、`老生代`两个区域，采用不同的策略管理垃圾回收
    * `新生代`的对象为`存活时间较短`的对象，简单来说就是新产生的对象。内存大小为`1M-8M`。
    * `老生代`的对象为`存活时间较长或常驻内存`的对象。老生代容量通常比较大

![v8垃圾回收优化-新生代、老生代](/images/JavaScript/v8垃圾回收优化-新生代、老生代.png)

### 新生代内存垃圾回收

* 新生代对象是通过一个名为`Scavenge 算法`进行垃圾回收，算法主要采用一种复制式的方式`Cheney 算法`
* `Cheney 算法`将内存一分为二，一个是处于使用状态的空间`使用区`，一种是出于闲置状态的空间`空闲区`

![垃圾回收优化-新生代回收](/images/JavaScript/垃圾回收优化-新生代回收.png)



## 参考

* [「硬核JS」你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214)
* [前端面试：谈谈 JS 垃圾回收机制](https://segmentfault.com/a/1190000018605776)
