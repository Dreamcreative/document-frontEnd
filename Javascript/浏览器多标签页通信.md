# 浏览器多标签页通信

1. BroadCastChannel
2. Service Worker
3. LocalStorage window.onstorage监听
4. window.open window.postMessage
5. SharedWorker(轮询 setInterval)
6. indexDB (轮询 setInterval)
7. cookie (轮询 setInterval)
8. webSocket

## BroadCastChannel

1. 同源通信：只支持 域名、端口、协议都相同的页面间通信
2. 通道命名：通过唯一频道名称建立连接
3. 数据格式：支持字符串/对象/ArrayBuffer 等结构化克隆数据类型
4. 兼容性：仅支持现代浏览器 ，IE 不支持
5. 性能：
   1. BroadcastChannel 直接内存传输，支持结构化对象，
   2. 瞬时传播
   3. 仅维持消息队列（自动垃圾回收）

```js
// 创建广播通道
const channel = new BroadcastChannel("channelName"); 
// 发送消息 
channel.postMessage("hello"); 
// 接收消息
channel.onmessage = (event) => {
    console.log(event.data);
} 
// 关闭通道
channel.close(); 
```

## Service Worker

1. 代理中间层：位于浏览器与网络之间
2. 独立线程运行：不阻塞主线程
3. 事件驱动模型：响应网络请求/推送/同步事件
4. 强制 HTTPS 协议（localhost 除外）
5. 严格校验缓存内容

## localstorage window.onstorage监听

window.onstorage 是浏览器在以下情况触发的事件

1. 同源页面修改 localStorage
2. 使用 `setItem()`/`removeItem()`方法
3. 值发生变化`（值相同时，不触发）`

* 注意事项

1. 存储容量限制：单个域名通常 5MB
2. 同步阻塞问题：避免大体积数据频繁写入
3. 隐私模式差异：Safari 隐私模式下无法使用
4. 移动端性能：低端设备写入速度较慢
5. onstorage 事件触发时机：`当前页面修改 localStorage,不会触发 onstorage 事件`，onstorage 事件仅监听其他同源页面的 localStorage 的修改
   1. onstorage：目的是实现不同标签页的数据同步
   2. 避免循环触发：防止当前页面操作引发自身的事件循环
   3. 触发条件严格：
      1. 修改发生在不同浏览器上下文（其他标签页/iframe）
      2. 使用标准 API (setItem/removeItem)
      3. 值改变（值相同时，不触发）

* 事件对象关键属性

```js

window.addEventListener('storage', event => {
  console.log('变更键名:', event.key);          // 被修改的键
  console.log('旧值:', event.oldValue);        // 修改前的值
  console.log('新值:', event.newValue);        // 修改后的值
  console.log('来源页:', event.url);           // 触发修改的页面URL
  console.log('存储对象:', event.storageArea); // 触发变更的存储对象
});
```

* 实际应用场景

1. 跨页面数据同步

```js
// A 页面
localStorage.setItem("key", "value");

// B 页面
window.addEventListener("storage", function (e) {
  if (e.key === "key" && e.newValue === "value") {
    console.log("同步成功");
  }
});
```

2. 用户行为追踪

```js
window.onstorage = function ({key, oldValue, newValue}) {
  if (key === "userActivity") {
    console.log("用户活动记录");
  }
};
```

3. 数据压缩传输

```js
// 使用LZString压缩
import LZString from 'lz-string';

const data = { /* 大数据对象 */ };
localStorage.setItem('compressed', LZString.compress(JSON.stringify(data)));

// 接收端解压
window.addEventListener('storage', ({key, newValue}) => {
  if(key === 'compressed') {
    const rawData = JSON.parse(LZString.decompress(newValue));
  }
});
```

## window.open window.postMessage


```js
// 父窗口
const childWindow = window.open('https://子域.example.com', 'childWindow', {});

// 发送消息到子窗口
childWindow.postMessage({ type: 'AUTH_TOKEN', data: 'xxxx' }, 'https://子域.example.com');


// 子窗口接收
window.addEventListener('message', (event) => {
  if (event.origin !== 'https://子域.example.com') {
    return;
  }
  const { type, data } = event.data;
  if (type === 'AUTH_TOKEN') {
    console.log(data);
  }
});
// 子窗口向父窗口发送
window.opener.postMessage({ type: 'AUTH_TOKEN', data: 'xxxx' }, 'https://父域.example.com');
```

## SharedWorker(轮询 setInterval)

* 核心特性

1. 多上下文共享：当个 Worker 实例可被同源所以页面共享
2. 持久化运行：即使所有页面关闭，仍可存活约 30S (浏览器策略)
3. 端口管理机制：需通过 MessagePort 进行双向通信

* 基础代码

```js
// shared-worker.js
const connections = [];
onconnect = (e) => {
  const port = e.ports[0];
  connections.push(port);
  
  port.onmessage = (event) => {
    // 广播消息到所有连接页面
    connections.forEach(p => {
      if (p !== port) p.postMessage(event.data);
    });
  };
};
```

* 页面端使用

```js
// 页面初始化
const worker = new SharedWorker('/shared-worker.js');
worker.port.start(); // 必须手动启动

// 发送消息
worker.port.postMessage({ type: 'SYNC', data: 123 });

// 接收消息
worker.port.onmessage = (e) => {
  console.log('收到广播:', e.data);
};
```

* 主要缺陷

1. 兼容性问题
* IOS Safari 全版本不支持
* Firefox 需启用 `dom.workers.sharedWorkers.enabled` 配置
2. 调试困难
3. 端口管理复杂度

## indexDB (轮询 setInterval)

* 核心特性
1. 结构化存储：支持复杂数据对象存储（JSON/二进制）
2. 索引查询：可创建多级索引实现快速检索
3. 事务支持：ACID 特性保障数据一致性
4. 异步操作：基于事件循环不阻塞主线程

* 基础操作模型

```js
// 打开数据库
const request = indexedDB.open('myDB', 3);

request.onupgradeneeded = (e) => {
  const db = e.target.result;
  if (!db.objectStoreNames.contains('users')) {
    const store = db.createObjectStore('users', { 
      keyPath: 'id',
      autoIncrement: true 
    });
    store.createIndex('email_idx', 'email', { unique: true });
  }
};

request.onsuccess = () => {
  const db = request.result;
  
  // 事务操作
  const tx = db.transaction('users', 'readwrite');
  const store = tx.objectStore('users');
  
  // 添加数据
  store.add({ email: 'test@example.com', age: 25 });
  
  // 索引查询
  const index = store.index('email_idx');
  index.get('test@example.com').onsuccess = (e) => {
    console.log('查询结果:', e.target.result);
  };
};
```

* 性能指标
1. 存储容量
   1. 桌面端：大于等于 50% 磁盘空间
   2. 移动端：大于等于 1G 各浏览器策略不同
2. 写入速度：约 1500次/秒（简单对象）
3. 索引查询：10万数据量下 < 5ms

* 适用场景
1. 离线应用数据缓存
2. 客户端大数据分析
3. 富媒体文件存储
4. 实时编辑草稿保存

* 安全注意事项
1. 同源隔离策略
2. 数据加密存储
3. 访问权限控制

## webSocket

* 核心机制
1. 全双工通道：单TCP连接双向通信
2. 低延迟传输
3. 持久化连接：心跳维持避免重复握手（默认30S间隔）

* 基础通信模型

```js
// 客户端连接
const ws = new WebSocket('wss://api.example.com/ws');

// 事件监听
ws.onopen = () => {
  console.log('连接建立耗时:', Date.now() - ws.startTime);
  ws.send(JSON.stringify({ type: 'AUTH', token: 'xxxx' }));
};

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  if(data.type === 'PRICE_UPDATE') {
    updateChart(data.payload);
  }
};

// 错误处理
ws.onerror = (error) => {
  console.error('WS错误:', error.message);
  setTimeout(connect, 5000); // 5秒后重连
};
```
