# 浏览器多标签页通信

1. BroadCastChannel
2. Service Worker
3. LocalStorage window.onstorage监听
4. window.open window.postMessage
5. SharedWorker(轮询 setInterval)
6. indexDB (轮询 setInterval)
7. cookie (轮询 setInterval)
8. webSocket

## BroadCastChannel

1. 同源通信：只支持 域名、端口、协议都相同的页面间通信
2. 通道命名：通过唯一频道名称建立连接
3. 数据格式：支持字符串/对象/ArrayBuffer 等结构化克隆数据类型
4. 兼容性：仅支持现代浏览器 ，IE 不支持
5. 性能：
   1. BroadcastChannel 直接内存传输，支持结构化对象，
   2. 瞬时传播
   3. 仅维持消息队列（自动垃圾回收）

```js
// 创建广播通道
const channel = new BroadcastChannel("channelName"); 
// 发送消息 
channel.postMessage("hello"); 
// 接收消息
channel.onmessage = (event) => {
    console.log(event.data);
} 
// 关闭通道
channel.close(); 
```

## Service Worker

1. 代理中间层：位于浏览器与网络之间
2. 独立线程运行：不阻塞主线程
3. 事件驱动模型：响应网络请求/推送/同步事件
4. 强制 HTTPS 协以（localhost 除外）
5. 严格校验缓存内容

## localstorage window.onstorage监听

window.onstorage 是浏览器在以下情况触发的事件

1. 同源页面修改 localStorage
2. 使用 `setItem()`/`removeItem()`方法
3. 值发生变化`（值相同时，不触发）`

* 注意事项

1. 存储容量限制：单个域名通常 5MB
2. 同步阻塞问题：避免大体积数据频繁写入
3. 隐私模式差异：Safari 隐私模式下无法使用
4. 移动端性能：低端设备写入速度较慢
5. onstorage 事件触发时机：`当前页面修改 localStorage,不会触发 onstorage 事件`，onstorage 事件仅监听其他同源页面的 localStorage 的修改
   1. onstorage：目的是实现不同标签页的数据同步
   2. 避免循环触发：防止当前页面操作引发自身的事件循环
   3. 触发条件严格：
      1. 修改发生在不同浏览器上下文（其他标签页/iframe）
      2. 使用标准 API (setItem/removeItem)
      3. 值改变（值相同时，不触发）

* 事件对象关键属性

```js

window.addEventListener('storage', event => {
  console.log('变更键名:', event.key);          // 被修改的键
  console.log('旧值:', event.oldValue);        // 修改前的值
  console.log('新值:', event.newValue);        // 修改后的值
  console.log('来源页:', event.url);           // 触发修改的页面URL
  console.log('存储对象:', event.storageArea); // 触发变更的存储对象
});
```

* 实际应用场景

1. 跨页面数据同步

```js
// A 页面
localStorage.setItem("key", "value");

// B 页面
window.addEventListener("storage", function (e) {
  if (e.key === "key" && e.newValue === "value") {
    console.log("同步成功");
  }
});
```

2. 用户行为追踪

```js
window.onstorage = function ({key, oldValue, newValue}) {
  if (key === "userActivity") {
    console.log("用户活动记录");
  }
};
```

3. 数据压缩传输

```js
// 使用LZString压缩
import LZString from 'lz-string';

const data = { /* 大数据对象 */ };
localStorage.setItem('compressed', LZString.compress(JSON.stringify(data)));

// 接收端解压
window.addEventListener('storage', ({key, newValue}) => {
  if(key === 'compressed') {
    const rawData = JSON.parse(LZString.decompress(newValue));
  }
});
```

## window.open window.postMessage


```js
// 父窗口
const childWindow = window.open('https://子域.example.com', 'childWindow', {});

// 发送消息到子窗口
childWindow.postMessage({ type: 'AUTH_TOKEN', data: 'xxxx' }, 'https://子域.example.com');


// 子窗口接收
window.addEventListener('message', (event) => {
  if (event.origin !== 'https://子域.example.com') {
    return;
  }
  const { type, data } = event.data;
  if (type === 'AUTH_TOKEN') {
    console.log(data);
  }
});
// 子窗口向父窗口发送
window.opener.postMessage({ type: 'AUTH_TOKEN', data: 'xxxx' }, 'https://父域.example.com');
```
