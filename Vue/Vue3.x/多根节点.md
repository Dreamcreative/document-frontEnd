# 多根节点

Vue3中允许使用多根节点，使用 `FRAGMENT` 进行包裹

* 主要实现方式

针对多根节点，Vue3针对多根节点，在编译过程中，将多根节点使用 `FRAGMENT` 进行包裹，使其在逻辑上成为一个整体，但在 DOM 中不会渲染多余的节点

```ts
// Vue3源码 packages/compiler-core/src/transform.ts
function createRootCodegen(root: RootNode, context: TransformContext) {
  const { helper } = context
  const { children } = root
  if (children.length === 1) {
    const singleElementRootChild = getSingleElementRoot(root)
    // if the single child is an element, turn it into a block.
    if (singleElementRootChild && singleElementRootChild.codegenNode) {
      // single element root is never hoisted so codegenNode will never be
      // SimpleExpressionNode
      const codegenNode = singleElementRootChild.codegenNode
      if (codegenNode.type === NodeTypes.VNODE_CALL) {
        convertToBlock(codegenNode, context)
      }
      root.codegenNode = codegenNode
    } else {
      // - single <slot/>, IfNode, ForNode: already blocks.
      // - single text node: always patched.
      // root codegen falls through via genNode()
      root.codegenNode = children[0]
    }
  } else if (children.length > 1) {
    // 多个根节点，使用 FRAGMENT 包裹
    // root has multiple nodes - return a fragment block.
    let patchFlag = PatchFlags.STABLE_FRAGMENT
    // check if the fragment actually contains a single valid child with
    // the rest being comments
    if (
      __DEV__ &&
      children.filter(c => c.type !== NodeTypes.COMMENT).length === 1
    ) {
      patchFlag |= PatchFlags.DEV_ROOT_FRAGMENT
    }
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      undefined,
      root.children,
      patchFlag,
      undefined,
      undefined,
      true,
      undefined,
      false /* isComponent */,
    )
  } else {
    // no children = noop. codegen will return null.
  }
}
```
